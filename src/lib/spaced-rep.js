// Generated by CoffeeScript 2.7.0
// spaced-rep.coffee
var RIGHT, WRONG, hDefOptions;

import {
  undef,
  defined,
  notdefined,
  getOptions,
  OL,
  isEmpty,
  nonEmpty,
  isString,
  isArray
} from '@jdeighan/base-utils';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  dbgEnter,
  dbgReturn,
  dbg
} from '@jdeighan/base-utils/debug';

import {
  BaseWordList
} from '@jdeighan/spaced-rep/basewordlist';

hDefOptions = {
  histLen: 5,
  workingSetSize: 7,
  pctReview: 5
};

// --- Default values used in history list for word in working set
RIGHT = 1;

WRONG = 2;

// ---------------------------------------------------------------------------
export var WordList = class WordList extends BaseWordList {
  constructor(hOptions = {}) {
    super(hOptions);
    this.lWorking = [];
    this.lLearned = [];
  }

  // ..........................................................
  getNextWordToLearn() {
    var word, workingSetSize;
    ({workingSetSize} = this.hOptions);
    if ((this.lLearned.length > 0) && this.lLearned[0].isDue()) {
      return this.lLearned[0];
    } else if ((this.lWorking.length > 0) && this.lWorking[0].isDue()) {
      return this.lWorking[0];
    } else if (this.lWorking.length < workingSetSize) {
      word = this.getNextUnseenWord();
      if (defined(word)) {
        this.lWorking.push(word);
        return word;
      } else {
        return undef; // no more words to learn
      }
    } else {
      return this.lWorking[0];
    }
  }

  // ..........................................................
  resultWas(word, result) {
    var lHist, lHistory, numCorrect, workingSetSize;
    ({workingSetSize} = this.hOptions);
    ({lHistory, numCorrect} = word);
    if (defined(numCorrect)) {
      if (result === RIGHT) {
        word.addCorrect();
      } else if (result === WRONG) {
        // --- was a known word, but got it wrong
        word.addHistory(WRONG);
      }
    // --- Move it from lLearned to lWorking
    // =============== TO DO ==============
    } else if (defined(lHistory)) {
      word.addHistory(result);
    }
    lHist = this.getHist(hWord);
    this.lHist.push(result);
    if (this.lHist.length > workingSetSize) {
      this.lHist.shift();
    }
  }

  // ..........................................................
  learnedOffset(word) {
    var numCorrect, numDays, result;
    // --- Returns a string like '10 minutes', '1 day', etc.
    dbgEnter('learnedOffset', word);
    ({numCorrect} = word);
    assert(defined(numCorrect), "Missing 'numCorrect' field");
    numDays = 2 ** numCorrect;
    dbg(`numDays = ${numDays}`);
    result = `${numDays} days`;
    dbg(`result = ${result}`);
    dbgReturn('learnedOffset', result);
    return result;
  }

  // ..........................................................
  workingOffset(word) {
    var history, i, item, len, numMinutes, result;
    // --- Returns a string like '10 minutes', '1 day', etc.
    dbgEnter('workingOffset', word);
    ({history} = word);
    assert(isArray(history), "Missing 'history' field");
    numMinutes = 2;
    for (i = 0, len = history.length; i < len; i++) {
      item = history[i];
      switch (item) {
        case RIGHT:
          numMinutes *= 2;
          break;
        case WRONG:
          numMinutes /= 2;
          break;
        default:
          croak(`Invalid history item: ${OL(item)}`);
      }
    }
    dbg(`numMinutes = ${numMinutes}`);
    result = `${numMinutes} minutes`;
    dbg(`result = ${result}`);
    dbgReturn('workingOffset', result);
    return result;
  }

};

// ---------------------------------------------------------------------------
export var LearnedWords = class LearnedWords {
  // ..........................................................
  workingDueTime(hWord) {
    // --- Returns a timestamp, i.e. num millisecs since the epoch
    return dbgEnter('workingDueTime', hWord);
  }

  // ..........................................................
  isDue(hWord) {
    var dueAt;
    ({dueAt} = hWord);
    if (notdefined(dueAt)) {
      return true;
    } else {
      return dueAt < Date.now();
    }
  }

  // ..........................................................
  getNextWordToLearn() {
    var hWord;
    if (isEmpty(this.hLearning)) {
      hWord = this.wordList.wordAt(0);
      return hWord;
    } else {
      return croak("not implemented");
    }
  }

  // ..........................................................
  // --- Get current word's history
  getHist(hWord) {
    if (hWord.hasOwnProperty('history')) {
      return hWord.history;
    } else {
      hWord.history = [];
      return hWord.history;
    }
  }

};

// ..........................................................
