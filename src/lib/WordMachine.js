// Generated by CoffeeScript 2.7.0
  // WordMachine.coffee
var hDefOptions,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

import {
  undef,
  defined,
  notdefined,
  range,
  deepEqual,
  getOptions
} from '@jdeighan/base-utils';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  StateMachine
} from '@jdeighan/base-utils/state-machine';

hDefOptions = {
  histLen: 5,
  workingSetSize: 7,
  pctReview: 5
};

// --- Default values used in history list for word in working set
export var RIGHT = 1;

export var WRONG = 2;

// ---------------------------------------------------------------------------
export var WordMachine = class WordMachine extends StateMachine {
  constructor(hOptions = {}) {
    var histLen;
    super('unseen');
    // ..........................................................
    // --- Default algorithm for determining whether a word is learned
    this.isLearned = this.isLearned.bind(this);
    this.hOptions = getOptions(hOptions, hDefOptions);
    ({histLen} = this.hOptions);
  }

  // ..........................................................
  setState() {
    return croak("Don't call setState()");
  }

  isLearned() {
    var i, item, len, numRight, numWrong, ref;
    boundMethodCheck(this, WordMachine);
    this.expectState('learning');
    numRight = 0;
    numWrong = 0;
    ref = this.lHistory;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (item === RIGHT) {
        numRight += 1;
      } else if (item === WRONG) {
        numWrong += 1;
      }
    }
    return (numRight - numWrong) >= 5;
  }

  // ..........................................................
  FETCH() {
    this.expectState('unseen');
    super.setState('learning', {
      lHistory: []
    });
    return this;
  }

  // ..........................................................
  TEST() {
    this.expectState('learning');
    super.setState('testing', {
      outcome: undef
    });
    return this;
  }

  // ..........................................................
  TEST_OUTCOME() {
    var histLen, lHistory, outcome;
    this.expectState('testing');
    this.expectDefined('outcome', 'lHistory');
    ({lHistory, outcome} = this.hData);
    ({histLen} = this.hOptions);
    lHistory.push(outcome);
    while (lHistory.length > histLen) {
      lHistory.shift();
    }
    if (this.isLearned()) {
      super.setState('learned', {
        numReviews: 0
      });
    } else {
      super.setState('learning');
    }
    return this;
  }

  // ..........................................................
  REVIEW() {
    this.expectState('learned');
    super.setState('reviewing', {
      outcome: undef
    });
    return this;
  }

  // ..........................................................
  REVIEW_OUTCOME() {
    var numReviews, outcome;
    this.expectState('reviewing');
    this.expectDefined('outcome');
    ({outcome, numReviews} = this.hData);
    if (outcome === RIGHT) {
      this.setVar('numReviews', numReviews + 1);
      super.setState('learned');
    } else {
      super.setState('learning', {
        lHistory: []
      });
    }
    return this;
  }

};
